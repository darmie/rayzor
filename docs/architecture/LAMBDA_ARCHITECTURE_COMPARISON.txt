╔══════════════════════════════════════════════════════════════════════════════╗
║                    LAMBDA LOWERING ARCHITECTURE COMPARISON                    ║
╚══════════════════════════════════════════════════════════════════════════════╝

┌──────────────────────────────────────────────────────────────────────────────┐
│ CURRENT ARCHITECTURE (Broken - 33% Tests Passing)                            │
└──────────────────────────────────────────────────────────────────────────────┘

Step 1: Build Signature (PREMATURE)
┌─────────────────────────────────┐
│ convert_type(body.ty) → IrType  │ ❌ WRONG! body.ty is unreliable
│         ↓                       │    (field access gives object ptr, not field type)
│ IrFunctionSignature {           │
│   return_type: IrType::Any/I64  │ ❌ Incorrect type
│ }                               │
└─────────────────────────────────┘
         ↓
Step 2: Add Function to Module
         ↓
Step 3: Switch Builder Context
         ↓
Step 4: Lower Body
┌─────────────────────────────────┐
│ Setup captures (manual locals)  │ ❌ Manual register tracking
│ lower_expression(body)          │
│   → generates instructions      │
│   → creates registers           │
│   → returns body_result         │
└─────────────────────────────────┘
         ↓
Step 5: Try to Fix Signature (TOO LATE)
┌─────────────────────────────────┐
│ Inspect terminator for return   │ ❌ Reference may be stale
│ Look up register type in locals │ ❌ Manual tracking incomplete
│ Update signature.return_type    │ ❌ Already used in terminators
└─────────────────────────────────┘
         ↓
RESULT: Type mismatches, verifier errors, 4/6 tests failing


┌──────────────────────────────────────────────────────────────────────────────┐
│ PROPOSED ARCHITECTURE (Fixed - 100% Tests Expected to Pass)                  │
└──────────────────────────────────────────────────────────────────────────────┘

PASS 1: Skeleton Creation
┌─────────────────────────────────┐
│ Allocate function ID             │
│ Build parameters list            │
│ Create PLACEHOLDER signature:   │
│   return_type: IrType::Any      │ ✅ Placeholder - will be fixed
│ Add empty function to module    │
└─────────────────────────────────┘
         ↓
PASS 2: Body Lowering + Type Inference
┌─────────────────────────────────┐
│ Switch to lambda context         │
│ Setup EnvironmentLayout          │ ✅ Abstracted, reusable
│   → Auto-calculates offsets      │
│   → Knows which fields need cast │
│ Lower body expression            │
│   → Builder auto-tracks types    │ ✅ No manual locals.insert()
│   → Generates all instructions   │
└─────────────────────────────────┘
         ↓
PASS 2 (continued): Return Type Inference
┌─────────────────────────────────┐
│ Scan CFG for return instructions │ ✅ Comprehensive search
│ Check explicit return terminators│ ✅ Handles all block types
│ Check body_result register type  │ ✅ Fallback for expressions
│ Extract ACTUAL type from locals  │ ✅ Reliable - from MIR
└─────────────────────────────────┘
         ↓
PASS 2 (continued): Signature Update
┌─────────────────────────────────┐
│ signature.return_type = inferred │ ✅ Correct type from actual IR
│ Validate all returns consistent  │ ✅ Early error detection
│ Finalize terminator if needed    │ ✅ Right time to create it
└─────────────────────────────────┘
         ↓
RESULT: Correct types, all tests passing


╔══════════════════════════════════════════════════════════════════════════════╗
║                         KEY ARCHITECTURAL CHANGES                             ║
╚══════════════════════════════════════════════════════════════════════════════╝

┌──────────────────────────────────────────────────────────────────────────────┐
│ 1. INFORMATION FLOW DIRECTION                                                │
└──────────────────────────────────────────────────────────────────────────────┘

BEFORE (Broken):
   HIR.ty (unreliable) → Signature → Body → Patch Signature
                           ↓
                        Used by terminators ❌
                        Can't patch retroactively!

AFTER (Fixed):
   Placeholder Signature → Body → Actual Types → Update Signature
                            ↓
                         Types extracted from MIR ✅
                         Signature updated BEFORE use!


┌──────────────────────────────────────────────────────────────────────────────┐
│ 2. REGISTER TYPE TRACKING                                                    │
└──────────────────────────────────────────────────────────────────────────────┘

BEFORE (Manual - Error-Prone):
   if let Some(lambda_func) = self.builder.module.functions.get_mut(&func_id) {
       lambda_func.locals.insert(reg1, IrLocal { ... }); ❌ Manual
       lambda_func.locals.insert(reg2, IrLocal { ... }); ❌ Easy to forget
       lambda_func.locals.insert(reg3, IrLocal { ... }); ❌ Duplicates possible
   }

AFTER (Automatic - Foolproof):
   impl IrBuilder {
       pub fn build_load(&mut self, ptr: IrId, ty: IrType) -> Option<IrId> {
           let dest = self.alloc_reg()?;
           self.register_local(dest, ty.clone()); ✅ Automatic
           self.add_instruction(IrInstruction::Load { dest, ptr, ty })?;
           Some(dest)
       }
   }


┌──────────────────────────────────────────────────────────────────────────────┐
│ 3. ENVIRONMENT LAYOUT                                                        │
└──────────────────────────────────────────────────────────────────────────────┘

BEFORE (Hardcoded):
   let field_offset = (field_index * 8) as i64; ❌ Assumes 8 bytes
   let loaded = builder.build_load(ptr, IrType::I64)?; ❌ No type info
   // Manual cast logic scattered everywhere ❌

AFTER (Abstracted):
   struct EnvironmentLayout {
       fields: Vec<EnvironmentField>, ✅ Type per field
       total_size: usize,              ✅ Calculated
       alignment: usize,               ✅ Platform-aware
   }

   layout.load_field(builder, env_ptr, symbol)? ✅ Single source of truth
       → Auto-calculates offset
       → Auto-inserts cast if needed
       → Consistent everywhere


┌──────────────────────────────────────────────────────────────────────────────┐
│ 4. RETURN TYPE DETECTION                                                     │
└──────────────────────────────────────────────────────────────────────────────┘

BEFORE (Incomplete):
   Check entry block only ❌
   Fails for expression blocks ❌
   Stale reference bugs ❌

AFTER (Comprehensive):
   fn infer_return_type(...) -> IrType {
       // Strategy 1: Explicit return
       if let Return { value } = block.terminator { ... } ✅

       // Strategy 2: Body result
       if let Some(result_reg) = body_result { ... } ✅

       // Strategy 3: CFG scan
       for block in function.cfg.blocks() { ... } ✅

       // Strategy 4: Validation
       validate_consistency(...)?; ✅

       // Fallback: Void
       IrType::Void ✅
   }


╔══════════════════════════════════════════════════════════════════════════════╗
║                            CONCRETE EXAMPLE                                   ║
╚══════════════════════════════════════════════════════════════════════════════╝

Input Haxe Code:
   var msg = new Message(42);
   var handle = Thread.spawn(() -> {
       return msg.value;  // Int field
   });

┌──────────────────────────────────────────────────────────────────────────────┐
│ CURRENT ARCHITECTURE (Fails)                                                 │
└──────────────────────────────────────────────────────────────────────────────┘

1. HIR: body.ty = TypeId(327) (Message object pointer) ❌
2. Convert: IrType::I64 (pointer type) ❌
3. Signature: return_type: I64 ❌
4. Lower body:
   - Load msg from capture → I64
   - Access msg.value field → I32 ✅ (correct!)
   - Return I32 value
5. Try to patch signature:
   - Terminator already created with I64 expectation ❌
   - Type lookup fails or returns wrong type ❌
6. Cranelift verifier: ERROR!
   "return v9: result has type i32, must match signature i64" ❌

┌──────────────────────────────────────────────────────────────────────────────┐
│ PROPOSED ARCHITECTURE (Works)                                                │
└──────────────────────────────────────────────────────────────────────────────┘

PASS 1: Create skeleton
1. Signature: return_type: Any (placeholder) ✅

PASS 2: Lower body
2. EnvironmentLayout:
   - Field 0: msg (object ptr, I64 storage) ✅
3. Load captures:
   - Load msg from env[0] → I64 ✅
   - Auto-tracked in locals ✅
4. Lower body:
   - Field access: msg.value
   - Load field → I32 ✅
   - Auto-tracked in locals ✅
5. Infer return type:
   - Find return terminator
   - Lookup v9 in locals → I32 ✅
   - return_type = I32 ✅
6. Update signature:
   - signature.return_type = I32 ✅
7. Create terminator:
   - Return { value: Some(v9) } ✅
   - Type already correct! ✅
8. Cranelift verifier: SUCCESS! ✅
   "function u0:0(i64) -> i32: verified" ✅


╔══════════════════════════════════════════════════════════════════════════════╗
║                         MIGRATION SAFETY                                      ║
╚══════════════════════════════════════════════════════════════════════════════╝

Phase 1: Preparation (ZERO risk)
   ✅ Already done:
      - Add ty to HirCapture
      - Update compute_captures
      - Add build_cast

   ⏭️  Next (low risk):
      - Create EnvironmentLayout (new code, doesn't touch existing)
      - Add builder helpers (additive only)

Phase 2: Refactoring (LOW risk)
   - Extract skeleton generation (pure refactor)
   - Implement infer_return_type (new function)
   - Update call sites incrementally

Phase 3: Replacement (MEDIUM risk - requires testing)
   - Replace generate_lambda_function
   - Remove manual locals tracking
   - Full test suite validation

Phase 4: Cleanup (LOW risk)
   - Remove debug code
   - Documentation
   - Performance check


╔══════════════════════════════════════════════════════════════════════════════╗
║                         SUCCESS METRICS                                       ║
╚══════════════════════════════════════════════════════════════════════════════╝

Current State:
   Tests passing:        2/6 (33%)   ❌
   Code complexity:      High         ❌
   Manual tracking:      Yes          ❌
   Type reliability:     Low          ❌
   Maintainability:      Poor         ❌

Expected After Migration:
   Tests passing:        6/6 (100%)  ✅
   Code complexity:      Medium       ✅
   Manual tracking:      No           ✅
   Type reliability:     High         ✅
   Maintainability:      Good         ✅
   Compilation time:     +5% slower   ⚠️ (acceptable tradeoff)


╔══════════════════════════════════════════════════════════════════════════════╗
║                            CONCLUSION                                         ║
╚══════════════════════════════════════════════════════════════════════════════╝

The current lambda lowering architecture is fundamentally broken due to:
   ❌ Backwards information flow (signature before types known)
   ❌ Manual state management (error-prone locals tracking)
   ❌ Unreliable type sources (HIR types don't match MIR reality)

The proposed two-pass architecture fixes ALL issues by:
   ✅ Correct information flow (types → signature)
   ✅ Automatic state management (builder handles locals)
   ✅ Reliable type inference (from actual MIR instructions)

Recommendation: Implement incrementally over 4 phases with comprehensive testing.
Estimated effort: 2-3 days
Risk level: Medium (but with clear migration path and safety checks)

Expected outcome: 100% test pass rate with cleaner, more maintainable code.

