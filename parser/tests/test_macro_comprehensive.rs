//! Comprehensive macro system tests
//!
//! This test file covers all aspects of Haxe macro system:
//! - Macro functions
//! - Macro reification
//! - Build macros
//! - Expression macros
//! - Type building macros

use parser::*;

#[test]
fn test_macro_function_basic() {
    let input = r#"
class MacroTools {
    macro public static function assert(expr:Expr):Expr {
        return macro {
            if (!$expr) {
                throw "Assertion failed";
            }
        };
    }
}
"#;

    let result = parse_haxe_file("test.hx", input, false);
    match &result {
        Ok(file) => {
            println!("✓ Basic macro function parsed successfully");
            // Verify the macro modifier is present
            if let TypeDeclaration::Class(class) = &file.declarations[0] {
                if let ClassFieldKind::Function(_func) = &class.fields[0].kind {
                    let has_macro = class.fields[0]
                        .modifiers
                        .iter()
                        .any(|m| matches!(m, Modifier::Macro));
                    assert!(has_macro, "Function should have macro modifier");
                }
            }
        }
        Err(e) => panic!("Failed to parse basic macro function: {}", e),
    }
}

#[test]
fn test_macro_block_expression() {
    let input = r#"
class Test {
    function buildExpr() {
        return macro {
            var x = 10;
            trace(x);
        };
    }
}
"#;

    let result = parse_haxe_file("test.hx", input, false);
    match &result {
        Ok(_) => println!("✓ Macro block expression parsed successfully"),
        Err(e) => panic!("Failed to parse macro block expression: {}", e),
    }
}

#[test]
fn test_macro_reification_simple() {
    let input = r#"
class Test {
    function test(e:Expr) {
        return macro $e;
    }
}
"#;

    let result = parse_haxe_file("test.hx", input, false);
    match &result {
        Ok(_) => println!("✓ Simple macro reification parsed successfully"),
        Err(e) => panic!("Failed to parse simple macro reification: {}", e),
    }
}

#[test]
fn test_macro_reification_in_block() {
    let input = r#"
class Test {
    function test(condition:Expr, body:Expr) {
        return macro {
            while ($condition) {
                $body;
            }
        };
    }
}
"#;

    let result = parse_haxe_file("test.hx", input, false);
    match &result {
        Ok(_) => println!("✓ Macro reification in block parsed successfully"),
        Err(e) => panic!("Failed to parse macro reification in block: {}", e),
    }
}

#[test]
fn test_dollar_identifiers_comprehensive() {
    let input = r#"
class Test {
    function test() {
        $type(expr);              // Type of expression
        $v{value};               // Value reification
        $i{identifier};          // Identifier reification
        $a{[expr1, expr2]};      // Array reification
        $b{block};               // Block reification
        $p{pattern};             // Pattern reification
        $e{expression};          // Expression reification
    }
}
"#;

    let result = parse_haxe_file("test.hx", input, false);
    match &result {
        Ok(_) => println!("✓ All dollar identifiers parsed successfully"),
        Err(e) => panic!("Failed to parse dollar identifiers: {}", e),
    }
}

#[test]
fn test_build_macro_class() {
    let input = r#"
@:build(MacroBuilder.build())
class Generated {
    // Fields will be generated by macro
}
"#;

    let result = parse_haxe_file("test.hx", input, false);
    match &result {
        Ok(file) => {
            println!("✓ Build macro class parsed successfully");
            if let TypeDeclaration::Class(class) = &file.declarations[0] {
                let has_build = class
                    .meta
                    .iter()
                    .any(|m| m.name == ":build" || m.name == "build");
                assert!(has_build, "Class should have @:build metadata");
            }
        }
        Err(e) => panic!("Failed to parse build macro class: {}", e),
    }
}

#[test]
fn test_autobuild_macro() {
    let input = r#"
@:autoBuild(MacroBuilder.autoBuild())
interface Component {
    function update():Void;
}
"#;

    let result = parse_haxe_file("test.hx", input, false);
    match &result {
        Ok(_) => println!("✓ AutoBuild macro interface parsed successfully"),
        Err(e) => panic!("Failed to parse autoBuild macro: {}", e),
    }
}

#[test]
fn test_macro_in_expression_position() {
    let input = r#"
class Test {
    function test() {
        var result = macro {
            trace("Generated at compile time");
        };
        return result;
    }
}
"#;

    let result = parse_haxe_file("test.hx", input, false);
    match &result {
        Ok(_) => println!("✓ Macro in expression position parsed successfully"),
        Err(e) => panic!("Failed to parse macro in expression position: {}", e),
    }
}

#[test]
fn test_macro_with_complex_reification() {
    let input = r#"
class MacroTools {
    macro public static function repeat(n:Int, expr:Expr):Expr {
        var exprs = [];
        for (i in 0...n) {
            exprs.push(macro {
                var i = $v{i};
                $expr;
            });
        }
        return macro $b{exprs};
    }
}
"#;

    let result = parse_haxe_file("test.hx", input, false);
    match &result {
        Ok(_) => println!("✓ Complex macro reification parsed successfully"),
        Err(e) => panic!("Failed to parse complex macro reification: {}", e),
    }
}

#[test]
fn test_macro_type_parameter() {
    let input = r#"
class Test {
    macro public static function makeTyped<T>(expr:ExprOf<T>):ExprOf<T> {
        return expr;
    }
}
"#;

    let result = parse_haxe_file("test.hx", input, false);
    match &result {
        Ok(_) => println!("✓ Macro with type parameter parsed successfully"),
        Err(e) => panic!("Failed to parse macro with type parameter: {}", e),
    }
}

#[test]
fn test_macro_class_reification() {
    let input = r#"
class Test {
    macro public static function defineClass(name:String):Expr {
        return macro class $name {
            public function new() {}
            public function hello() {
                trace("Hello from " + $v{name});
            }
        };
    }
}
"#;

    let result = parse_haxe_file("test.hx", input, false);
    match &result {
        Ok(_) => println!("✓ Macro class reification parsed successfully"),
        Err(e) => {
            println!("✗ Failed to parse macro class reification: {}", e);
            println!("Note: This is an advanced feature that may need special handling");
        }
    }
}

#[test]
fn test_macro_static_extension() {
    let input = r#"
class MacroExtensions {
    macro public static function times(target:Expr, n:Int):Expr {
        return macro {
            for (_ in 0...$v{n}) {
                $target;
            }
        };
    }
}

class Usage {
    static function main() {
        using MacroExtensions;
        trace("Hello").times(3);
    }
}
"#;

    let result = parse_haxe_file("test.hx", input, false);
    match &result {
        Ok(_) => println!("✓ Macro static extension parsed successfully"),
        Err(e) => panic!("Failed to parse macro static extension: {}", e),
    }
}

#[test]
fn test_generic_build_macro() {
    let input = r#"
@:genericBuild(Macro.build())
class Container<T> {}
"#;

    let result = parse_haxe_file("test.hx", input, false);
    match &result {
        Ok(_) => println!("✓ Generic build macro parsed successfully"),
        Err(e) => panic!("Failed to parse generic build macro: {}", e),
    }
}

// Test error cases and edge cases
#[test]
fn test_macro_edge_cases() {
    // Test macro without return type
    let input1 = r#"
class Test {
    macro function test(e:Expr) {
        return e;
    }
}
"#;
    assert!(
        parse_haxe_file("test.hx", input1, false).is_ok(),
        "Macro without return type should parse"
    );

    // Test macro with metadata
    let input2 = r#"
class Test {
    @:dce("full")
    macro public static function test():Expr {
        return macro null;
    }
}
"#;
    assert!(
        parse_haxe_file("test.hx", input2, false).is_ok(),
        "Macro with metadata should parse"
    );

    // Test nested macro blocks
    let input3 = r#"
class Test {
    macro function test() {
        return macro {
            var inner = macro {
                trace("nested");
            };
            $inner;
        };
    }
}
"#;
    assert!(
        parse_haxe_file("test.hx", input3, false).is_ok(),
        "Nested macro blocks should parse"
    );
}

#[test]
fn test_run_time_vs_compile_time() {
    // This test verifies we can distinguish between compile-time and run-time code
    let input = r#"
class Macros {
    // Compile-time function
    macro public static function getCurrentTime():Expr {
        var time = Date.now().toString();
        return macro $v{time};
    }
    
    // Run-time function using the macro
    public static function printCompileTime() {
        trace("Compiled at: " + getCurrentTime());
    }
}
"#;

    let result = parse_haxe_file("test.hx", input, false);
    match &result {
        Ok(_) => println!("✓ Compile-time vs run-time code parsed successfully"),
        Err(e) => panic!("Failed to parse compile/run-time code: {}", e),
    }
}
