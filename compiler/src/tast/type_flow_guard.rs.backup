//! TypeFlowGuard - Flow-sensitive safety analysis using existing CFG infrastructure
//!
//! This module provides TypeFlowGuard, a flow-sensitive safety analysis system that 
//! leverages our existing sophisticated CFG infrastructure from the semantic_graph module
//! instead of building redundant control flow analysis.

use crate::semantic_graph::{
    cfg::{ControlFlowGraph, BasicBlock},
    tast_cfg_mapping::{TastCfgMapping, StatementLocation},
    builder::CfgBuilder,
    GraphConstructionOptions,
};
use crate::tast::{
    node::{TypedFile, TypedFunction, TypedStatement, TypedExpression, TypedExpressionKind},
    BlockId, SymbolId, SourceLocation, SymbolTable, TypeTable,
};
use std::collections::{HashMap, HashSet};
use std::cell::RefCell;

/// TypeFlowGuard safety violation 
#[derive(Debug, Clone)]
pub enum FlowSafetyError {
    /// Variable used before initialization
    UninitializedVariable {
        variable: SymbolId,
        location: SourceLocation,
    },
    /// Potential null dereference
    NullDereference {
        variable: SymbolId,
        location: SourceLocation,
    },
    /// Dead code detected
    DeadCode {
        location: SourceLocation,
    },
    /// Resource leak detected
    ResourceLeak {
        resource: SymbolId,
        location: SourceLocation,
    },
}

/// Results of TypeFlowGuard safety analysis
#[derive(Debug, Default)]
pub struct FlowSafetyResults {
    /// All safety violations found during analysis
    pub errors: Vec<FlowSafetyError>,
    /// Warnings that don't prevent compilation
    pub warnings: Vec<FlowSafetyError>,
    /// Performance metrics
    pub metrics: FlowAnalysisMetrics,
}

/// Performance metrics for flow analysis
#[derive(Debug, Default)]
pub struct FlowAnalysisMetrics {
    /// Time spent on CFG construction (microseconds)
    pub cfg_construction_time_us: u64,
    /// Time spent on variable state analysis (microseconds)
    pub variable_analysis_time_us: u64,
    /// Time spent on null safety analysis (microseconds)
    pub null_safety_time_us: u64,
    /// Time spent on dead code analysis (microseconds)
    pub dead_code_time_us: u64,
    /// Number of functions analyzed
    pub functions_analyzed: usize,
    /// Number of basic blocks processed
    pub blocks_processed: usize,
}

/// Variable state in flow analysis
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum VariableState {
    /// Variable is uninitialized
    Uninitialized,
    /// Variable is initialized with a value
    Initialized,
    /// Variable might be initialized (from different control flow paths)
    MaybeInitialized,
    /// Variable is definitely null
    Null,
    /// Variable is definitely not null
    NotNull,
    /// Variable might be null
    MaybeNull,
}

/// TypeFlowGuard - Flow-sensitive safety analysis using existing CFG
pub struct TypeFlowGuard<'a> {
    /// Symbol table
    symbol_table: &'a SymbolTable,
    /// Type table
    type_table: &'a RefCell<TypeTable>,
    /// CFG builder for constructing control flow graphs
    cfg_builder: CfgBuilder,
    /// Results accumulator
    pub (crate) results: FlowSafetyResults,
}

impl<'a> TypeFlowGuard<'a> {
    /// Create a new TypeFlowGuard analyzer
    pub fn new(
        symbol_table: &'a SymbolTable,
        type_table: &'a RefCell<TypeTable>,
    ) -> Self {
        Self {
            symbol_table,
            type_table,
            cfg_builder: CfgBuilder::new(GraphConstructionOptions::default()),
            results: FlowSafetyResults::default(),
        }
    }
    
    /// Perform flow safety analysis on a file
    pub fn analyze_file(&mut self, file: &TypedFile) -> FlowSafetyResults {
        let _start_time = std::time::Instant::now();
        
        // Analyze each function in the file
        for function in &file.functions {
            self.analyze_function(function);
        }
        
        // Update metrics
        self.results.metrics.functions_analyzed = file.functions.len();
        
        std::mem::take(&mut self.results)
    }
    
    /// Analyze a single function for flow safety
    pub fn analyze_function(&mut self, function: &TypedFunction) {
        let _start_time = std::time::Instant::now();
        
        // Step 1: Build CFG using existing infrastructure
        let cfg_start = std::time::Instant::now();
        let cfg = match self.cfg_builder.build_function(function) {
            Ok(cfg) => cfg,
            Err(e) => {
                // If CFG construction fails, still update metrics and provide debug info
                eprintln!("CFG construction failed for function {}: {:?}", 
                         function.symbol_id.as_raw(), e);
                self.results.metrics.functions_analyzed += 1;
                return;
            }
        };
        let mapping = TastCfgMapping::build(&cfg, function);
        self.results.metrics.cfg_construction_time_us += cfg_start.elapsed().as_micros() as u64;
        
        // Step 2: Variable state analysis
        let var_start = std::time::Instant::now();
        self.analyze_variable_states(&cfg, &mapping.mapping, function);
        self.results.metrics.variable_analysis_time_us += var_start.elapsed().as_micros() as u64;
        
        // Step 3: Null safety analysis
        let null_start = std::time::Instant::now();
        self.analyze_null_safety(&cfg, &mapping.mapping, function);
        self.results.metrics.null_safety_time_us += null_start.elapsed().as_micros() as u64;
        
        // Step 4: Dead code analysis
        let dead_start = std::time::Instant::now();
        self.analyze_dead_code(&cfg, &mapping.mapping);
        self.results.metrics.dead_code_time_us += dead_start.elapsed().as_micros() as u64;
        
        // Update metrics
        self.results.metrics.blocks_processed += cfg.blocks.len();
        self.results.metrics.functions_analyzed += 1;
    }
    
    /// Analyze variable initialization states using CFG
    fn analyze_variable_states(
        &mut self,
        cfg: &ControlFlowGraph,
        mapping: &TastCfgMapping,
        function: &TypedFunction,
    ) {
        // Track variable states across basic blocks
        let mut block_states: HashMap<BlockId, HashMap<SymbolId, VariableState>> = HashMap::new();
        let mut variables: HashSet<SymbolId> = HashSet::new();
        
        // Collect all variables in the function
        self.collect_variables(function, &mut variables);
        
        // Initialize entry block with all variables uninitialized
        let entry_block = cfg.entry_block;
        let mut initial_state = HashMap::new();
        for &var in &variables {
            initial_state.insert(var, VariableState::Uninitialized);
        }
        block_states.insert(entry_block, initial_state);
        
        // Worklist algorithm for data flow analysis
        let worklist: Vec<BlockId> = cfg.blocks.keys().cloned().collect();
        let mut changed = true;
        
        while changed {
            changed = false;
            
            for &block_id in &worklist {
                if let Some(block) = cfg.blocks.get(&block_id) {
                    let old_state = block_states.get(&block_id).cloned().unwrap_or_default();
                    let new_state = self.analyze_block_variables(block, &old_state, mapping, function);
                    
                    if new_state != old_state {
                        block_states.insert(block_id, new_state.clone());
                        changed = true;
                        
                        // Propagate to successors
                        for &succ_id in &block.successors {
                            self.merge_states(&mut block_states, succ_id, &new_state);
                        }
                    }
                }
            }
        }
        
        // Check for uninitialized variable uses
        for (block_id, state) in &block_states {
            if let Some(block) = cfg.blocks.get(block_id) {
                self.check_uninitialized_uses(block, state, mapping, function);
            }
        }
    }
    
    /// Analyze null safety using CFG
    fn analyze_null_safety(
        &mut self,
        cfg: &ControlFlowGraph,
        mapping: &TastCfgMapping,
        function: &TypedFunction,
    ) {
        // Similar to variable state analysis but for null states
        let mut block_null_states: HashMap<BlockId, HashMap<SymbolId, VariableState>> = HashMap::new();
        
        // Track null assignments and dereferences
        for (block_id, block) in &cfg.blocks {
            let null_state = self.analyze_block_null_safety(block, mapping, function);
            block_null_states.insert(*block_id, null_state);
        }
        
        // Check for potential null dereferences
        for (block_id, null_state) in &block_null_states {
            if let Some(block) = cfg.blocks.get(block_id) {
                self.check_null_dereferences(block, null_state, mapping, function);
            }
        }
    }
    
    /// Analyze dead code using CFG reachability
    fn analyze_dead_code(&mut self, cfg: &ControlFlowGraph, _mapping: &TastCfgMapping) {
        // Use CFG reachability to find unreachable blocks
        let mut reachable: HashSet<BlockId> = HashSet::new();
        
        let entry_block = cfg.entry_block;
        self.mark_reachable(cfg, entry_block, &mut reachable);
        
        // Report unreachable blocks as dead code
        for &block_id in cfg.blocks.keys() {
            if !reachable.contains(&block_id) {
                if let Some(block) = cfg.blocks.get(&block_id) {
                    self.results.warnings.push(FlowSafetyError::DeadCode {
                        location: block.source_location,
                    });
                }
            }
        }
    }
    
    // Helper methods
    
    fn collect_variables(&self, function: &TypedFunction, variables: &mut HashSet<SymbolId>) {
        for statement in &function.body {
            self.collect_variables_from_statement(statement, variables);
        }
    }
    
    fn collect_variables_from_statement(&self, statement: &TypedStatement, variables: &mut HashSet<SymbolId>) {
        match statement {
            TypedStatement::VarDeclaration { symbol_id, .. } => {
                variables.insert(*symbol_id);
            }
            TypedStatement::Assignment { target, .. } => {
                self.collect_variables_from_expression(target, variables);
            }
            TypedStatement::Expression { expression, .. } => {
                self.collect_variables_from_expression(expression, variables);
            }
            TypedStatement::Return { value, .. } => {
                if let Some(expr) = value {
                    self.collect_variables_from_expression(expr, variables);
                }
            }
            TypedStatement::If { condition, then_branch, else_branch, .. } => {
                self.collect_variables_from_expression(condition, variables);
                self.collect_variables_from_statement(then_branch, variables);
                if let Some(else_stmt) = else_branch {
                    self.collect_variables_from_statement(else_stmt, variables);
                }
            }
            TypedStatement::Block { statements, .. } => {
                for stmt in statements {
                    self.collect_variables_from_statement(stmt, variables);
                }
            }
            _ => {} // Handle other statement types as needed
        }
    }
    
    fn collect_variables_from_expression(&self, expression: &TypedExpression, variables: &mut HashSet<SymbolId>) {
        match &expression.kind {
            TypedExpressionKind::Variable { symbol_id } => {
                variables.insert(*symbol_id);
            }
            TypedExpressionKind::BinaryOp { left, right, .. } => {
                self.collect_variables_from_expression(left, variables);
                self.collect_variables_from_expression(right, variables);
            }
            TypedExpressionKind::FieldAccess { object, .. } => {
                self.collect_variables_from_expression(object, variables);
            }
            _ => {} // Handle other expression types as needed
        }
    }
    
    fn analyze_block_variables(
        &self,
        block: &BasicBlock,
        input_state: &HashMap<SymbolId, VariableState>,
        mapping: &TastCfgMapping,
        function: &TypedFunction,
    ) -> HashMap<SymbolId, VariableState> {
        let mut state = input_state.clone();
        
        // Get statements that map to this block using the TastCfgMapping
        let statement_locations = mapping.get_statements_in_block(block.id);
        for stmt_loc in statement_locations {
            if let Some(statement) = self.get_statement_by_location(function, stmt_loc) {
                self.process_statement_for_variables(statement, &mut state);
            }
        }
        
        state
    }
    
    fn analyze_block_null_safety(
        &self,
        block: &BasicBlock,
        mapping: &TastCfgMapping,
        function: &TypedFunction,
    ) -> HashMap<SymbolId, VariableState> {
        let mut null_state = HashMap::new();
        
        // Get statements that map to this block using the TastCfgMapping
        let statement_locations = mapping.get_statements_in_block(block.id);
        for stmt_loc in statement_locations {
            if let Some(statement) = self.get_statement_by_location(function, stmt_loc) {
                self.process_statement_for_null_safety(statement, &mut null_state);
            }
        }
        
        null_state
    }
    
    fn merge_states(
        &self,
        block_states: &mut HashMap<BlockId, HashMap<SymbolId, VariableState>>,
        block_id: BlockId,
        incoming_state: &HashMap<SymbolId, VariableState>,
    ) {
        // Merge incoming state with existing state for this block
        let existing_state = block_states.entry(block_id).or_insert_with(HashMap::new);
        
        for (&var, &incoming_val) in incoming_state {
            let current_val = existing_state.get(&var).copied().unwrap_or(VariableState::Uninitialized);
            let merged_val = self.merge_variable_states(current_val, incoming_val);
            existing_state.insert(var, merged_val);
        }
    }
    
    fn merge_variable_states(&self, state1: VariableState, state2: VariableState) -> VariableState {
        match (state1, state2) {
            (VariableState::Initialized, VariableState::Initialized) => VariableState::Initialized,
            (VariableState::Uninitialized, VariableState::Uninitialized) => VariableState::Uninitialized,
            (VariableState::Null, VariableState::Null) => VariableState::Null,
            (VariableState::NotNull, VariableState::NotNull) => VariableState::NotNull,
            // Any mismatch results in "maybe" state
            (VariableState::Initialized, VariableState::Uninitialized) |
            (VariableState::Uninitialized, VariableState::Initialized) => VariableState::MaybeInitialized,
            (VariableState::Null, VariableState::NotNull) |
            (VariableState::NotNull, VariableState::Null) => VariableState::MaybeNull,
            _ => VariableState::MaybeInitialized, // Conservative merge
        }
    }
    
    fn check_uninitialized_uses(
        &mut self,
        block: &BasicBlock,
        state: &HashMap<SymbolId, VariableState>,
        mapping: &TastCfgMapping,
        function: &TypedFunction,
    ) {
        // Check for uses of uninitialized variables in this block
        let statement_locations = mapping.get_statements_in_block(block.id);
        for stmt_loc in statement_locations {
            if let Some(statement) = self.get_statement_by_location(function, stmt_loc) {
                self.check_statement_for_uninitialized_uses(statement, state);
            }
        }
    }
    
    fn check_null_dereferences(
        &mut self,
        block: &BasicBlock,
        null_state: &HashMap<SymbolId, VariableState>,
        mapping: &TastCfgMapping,
        function: &TypedFunction,
    ) {
        // Check for null dereferences in this block
        let statement_locations = mapping.get_statements_in_block(block.id);
        for stmt_loc in statement_locations {
            if let Some(statement) = self.get_statement_by_location(function, stmt_loc) {
                self.check_statement_for_null_dereferences(statement, null_state);
            }
        }
    }
    
    fn mark_reachable(&self, cfg: &ControlFlowGraph, block_id: BlockId, reachable: &mut HashSet<BlockId>) {
        if reachable.contains(&block_id) {
            return; // Already visited
        }
        
        reachable.insert(block_id);
        
        if let Some(block) = cfg.blocks.get(&block_id) {
            // Mark all successors as reachable
            for &succ_id in &block.successors {
                self.mark_reachable(cfg, succ_id, reachable);
            }
        }
    }
    
    /// Get statement by location within function
    fn get_statement_by_location<'b>(&self, function: &'b TypedFunction, location: &StatementLocation) -> Option<&'b TypedStatement> {
        // Map StatementLocation to actual statement in function body
        // This is a simplified implementation - in practice, we'd need more sophisticated mapping
        if location.statement_index < function.body.len() {
            Some(&function.body[location.statement_index])
        } else {
            None
        }
    }
    
    /// Process a statement to update variable initialization states
    fn process_statement_for_variables(&self, statement: &TypedStatement, state: &mut HashMap<SymbolId, VariableState>) {
        match statement {
            TypedStatement::VarDeclaration { symbol_id, initializer, .. } => {
                if initializer.is_some() {
                    state.insert(*symbol_id, VariableState::Initialized);
                } else {
                    state.insert(*symbol_id, VariableState::Uninitialized);
                }
            }
            TypedStatement::Assignment { target, value, .. } => {
                // Extract variable from assignment target
                if let TypedExpressionKind::Variable { symbol_id } = &target.kind {
                    let new_state = if self.is_null_expression(value) {
                        VariableState::Null
                    } else {
                        VariableState::Initialized
                    };
                    state.insert(*symbol_id, new_state);
                }
            }
            _ => {} // Other statements don't affect variable initialization
        }
    }
    
    /// Process a statement for null safety analysis
    fn process_statement_for_null_safety(&self, statement: &TypedStatement, null_state: &mut HashMap<SymbolId, VariableState>) {
        match statement {
            TypedStatement::VarDeclaration { symbol_id, initializer, .. } => {
                if let Some(init_expr) = initializer {
                    let state = if self.is_null_expression(init_expr) {
                        VariableState::Null
                    } else {
                        VariableState::NotNull
                    };
                    null_state.insert(*symbol_id, state);
                } else {
                    null_state.insert(*symbol_id, VariableState::MaybeNull);
                }
            }
            TypedStatement::Assignment { target, value, .. } => {
                if let TypedExpressionKind::Variable { symbol_id } = &target.kind {
                    let state = if self.is_null_expression(value) {
                        VariableState::Null
                    } else {
                        VariableState::NotNull
                    };
                    null_state.insert(*symbol_id, state);
                }
            }
            _ => {}
        }
    }
    
    /// Check a statement for uninitialized variable uses
    fn check_statement_for_uninitialized_uses(&mut self, statement: &TypedStatement, state: &HashMap<SymbolId, VariableState>) {
        // Collect errors first, then add them to avoid borrowing conflicts
        let mut errors = Vec::new();
        
        match statement {
            TypedStatement::Return { value, .. } => {
                if let Some(expr) = value {
                    self.collect_uninitialized_errors(expr, state, &mut errors);
                }
            }
            TypedStatement::Assignment { value, .. } => {
                self.collect_uninitialized_errors(value, state, &mut errors);
            }
            TypedStatement::Expression { expression, .. } => {
                self.collect_uninitialized_errors(expression, state, &mut errors);
            }
            TypedStatement::If { condition, .. } => {
                self.collect_uninitialized_errors(condition, state, &mut errors);
            }
            _ => {}
        }
        
        // Now add the errors
        self.results.errors.extend(errors);
    }
    
    /// Collect uninitialized variable errors from an expression
    fn collect_uninitialized_errors(&self, expr: &TypedExpression, state: &HashMap<SymbolId, VariableState>, errors: &mut Vec<FlowSafetyError>) {
        match &expr.kind {
            TypedExpressionKind::Variable { symbol_id } => {
                if let Some(&var_state) = state.get(symbol_id) {
                    if var_state == VariableState::Uninitialized {
                        errors.push(FlowSafetyError::UninitializedVariable {
                            variable: *symbol_id,
                            location: expr.source_location,
                        });
                    }
                }
            }
            TypedExpressionKind::BinaryOp { left, right, .. } => {
                self.collect_uninitialized_errors(left, state, errors);
                self.collect_uninitialized_errors(right, state, errors);
            }
            TypedExpressionKind::FieldAccess { object, .. } => {
                self.collect_uninitialized_errors(object, state, errors);
            }
            _ => {}
        }
    }
    
    /// Check a statement for null dereferences
    fn check_statement_for_null_dereferences(&mut self, statement: &TypedStatement, null_state: &HashMap<SymbolId, VariableState>) {
        // Collect errors first, then add them to avoid borrowing conflicts
        let mut errors = Vec::new();
        
        match statement {
            TypedStatement::Return { value, .. } => {
                if let Some(expr) = value {
                    self.collect_null_dereference_errors(expr, null_state, &mut errors);
                }
            }
            TypedStatement::Assignment { value, .. } => {
                self.collect_null_dereference_errors(value, null_state, &mut errors);
            }
            TypedStatement::Expression { expression, .. } => {
                self.collect_null_dereference_errors(expression, null_state, &mut errors);
            }
            TypedStatement::If { condition, .. } => {
                self.collect_null_dereference_errors(condition, null_state, &mut errors);
            }
            _ => {}
        }
        
        // Now add the errors
        self.results.errors.extend(errors);
    }
    
    /// Collect null dereference errors from an expression
    fn collect_null_dereference_errors(&self, expr: &TypedExpression, null_state: &HashMap<SymbolId, VariableState>, errors: &mut Vec<FlowSafetyError>) {
        match &expr.kind {
            TypedExpressionKind::FieldAccess { object, .. } => {
                // Check if the object being accessed might be null
                if let TypedExpressionKind::Variable { symbol_id } = &object.kind {
                    if let Some(&var_state) = null_state.get(symbol_id) {
                        if var_state == VariableState::Null || var_state == VariableState::MaybeNull {
                            errors.push(FlowSafetyError::NullDereference {
                                variable: *symbol_id,
                                location: expr.source_location,
                            });
                        }
                    }
                }
                // Recursively check the object expression
                self.collect_null_dereference_errors(object, null_state, errors);
            }
            TypedExpressionKind::BinaryOp { left, right, .. } => {
                self.collect_null_dereference_errors(left, null_state, errors);
                self.collect_null_dereference_errors(right, null_state, errors);
            }
            _ => {}
        }
    }
    
    /// Check if an expression represents a null value
    fn is_null_expression(&self, expr: &TypedExpression) -> bool {
        match &expr.kind {
            TypedExpressionKind::Literal { value } => {
                // For now, assume no literals are null - extend as needed
                false
            }
            _ => false,
        }
    }
    
    /// Get the analysis results
    pub fn get_results(&self) -> &FlowSafetyResults {
        &self.results
    }
    
    /// Take the analysis results (consuming the analyzer)
    pub fn into_results(self) -> FlowSafetyResults {
        self.results
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_variable_state_merge() {
        let symbol_table = SymbolTable::new();
        let type_table = RefCell::new(TypeTable::new());
        let guard = TypeFlowGuard::new(&symbol_table, &type_table);
        
        // Test merging initialized and uninitialized
        let merged = guard.merge_variable_states(
            VariableState::Initialized, 
            VariableState::Uninitialized
        );
        assert_eq!(merged, VariableState::MaybeInitialized);
        
        // Test merging null and not-null
        let merged = guard.merge_variable_states(
            VariableState::Null, 
            VariableState::NotNull
        );
        assert_eq!(merged, VariableState::MaybeNull);
    }
}